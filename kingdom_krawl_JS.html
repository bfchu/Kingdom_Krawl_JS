<!doctype html>
<title>Kingdom Krawl </title>

<style>

body {
	background-color: black;
}

canvas { 
	display: block;
	margin-left: auto;
	margin-right: auto;
	border: 1px solid gold; 
	background-color: black;
}

textarea{
	display: block;
	margin-left: auto;
	margin-right: auto;
	resize:none;
	background-color: black;
	border: 1px solid gold;
	color: white;
}

</style>

<head>
<canvas id="gameDisplay" width="672" height="416"></canvas>
<textarea id="outputText" cols="80" rows="12" readonly="readonly"></textarea>

<script src="scripts/imageLoader.js"></script>
<script>
/*////////////////////////////////////////////
///			Kingdom Krawl JS   v0.0.8      //
//////////////////////////////////////////////////
///
//	Author: Brian F. Chu
//	Art: Brian Chu and Eli Boggs
//	Copyright 2013 SNS Games
//	Santa Rosa, CA, USA
//
//
//////////////////////////////////////////////////
///
//	Features:
	+ Procedurally generated dungeon layout
	+ Randomized placement of loot and enemies
	+ Enemies given random strength levels and health
	+ 'Camera' follows player as they move and snaps to corners/walls of the grid.
	+ 8-direction movement using the numpad
	+ press numpad5 to wait, rest, and view your HP/MP
	+ supports sprite tiles
	+ simulates dice-rolling for getting random numbers.
	+ character job class system, used for player character and monsters, allows for random starting gold.
		-player class is pre-selected in code currently. later there will be a selection screen.
	+ dungeon features such as doors, portals, stairs, traps, ect...
	+ allow player to interact with features such as stairs and portals to traverse floors.
	+ multiple floors/rooms.

	+ TODO: dungeon features such as traps, fountains, ect...
	+ TODO: documentation...

//////////////////////////////////////////////////
///
//	Known Bugs:
//	- floor.createReciprocal() not working correctly.
//	- portals sometimes take you to their own location.
//	- RESOLVED:items (such as gold) are sometimes duplicated nearby eachother. both disapear if you pick up one of them.
//		-related: sometimes adjacent enemies will die at the same time, even if they are different types.
//	- RESOLVED:sometimes enemies are dying multiple times if they are one-shot.
//
//
//
/////////////////////////////////////////////////*/

//Image Loading:
//tiles
imageLoader.queueImage("wall");
imageLoader.queueImage("floor");
imageLoader.queueImage("water");
imageLoader.queueImage("black");

//features
imageLoader.queueImage("door");
imageLoader.queueImage("portal");

//items
imageLoader.queueImage("treasure");

//creatures
imageLoader.queueImage("hero");
imageLoader.queueImage("goblin");
imageLoader.queueImage("golem");
imageLoader.queueImage("dragon");


//game settings:
const WORLD_SEED = new Date().getTime();
const WORLD_SIZE = 72;		// any positive number
const WORLD_DEPTH = 9;
const TILE_SIZE = 32;		// should be a power of 2
const DISPLAY_WIDTH = 21; 	// needs to be an odd integer
const DISPLAY_HEIGHT = 13;	// needs to be an odd integer
const ENEMY_DENSITY =  0.3; //rate of enemy occurance per row. Number between 0 and 1 is suggested.
const NUM_ENEMIES = Math.floor(WORLD_SIZE * ENEMY_DENSITY);	// defines how many enemies will be randomly generated
const EXP_RATE = 2; 		// multiplier on exp gains.
const DAMAGE_RATE = 0.2; 	// multiplier on attack damage. affects the way STRONGTH effects damage result



var Dice = {
	//need to change this function to also accept dice is am XdY format (1d4, 2d6, 1d100...)
	roll: function (numDice, dieSize){
		var dRoll = 0;
		for(var ii = 0; ii < numDice; ii++){
			dRoll += (Math.floor(Math.random(WORLD_SEED)*100) % dieSize) + 1;
		}
		return dRoll;
	},

	rollPercent: function (){
		return (Math.floor(Math.random(WORLD_SEED)*100) % 100) + 1;
	}
};

var turnCount = 0;


var world = []
var floorCount = 0;

//TILES
//function TileDefinition(name, icon, isWalkable)
var tileDefinitions = []; //defines the default properties of tile types.
tileDefinitions[0] = new TileDefinition("WALL", "wall", false);
tileDefinitions[1] = new TileDefinition("FLOOR", "floor", true);
tileDefinitions[2] = new TileDefinition("WATER", "water", false);
tileDefinitions[3] = new TileDefinition("PIT", "black", false);

function getTileDef(id){
	switch(id.toUpperCase()){
		case "FLOOR":
			return tileDefinitions[1];
		case "WATER":
			return tileDefinitions[2];
		case "PIT":
			return tileDefinitions[3];
		case "WALL":
		default:
			return tileDefinitions[0];
	}
}

var features = []; //used for storing dungeon features like doors, stairs, fountains...
var featureCount = 0;

var creatures = []; //used for storing non-player characters
var creatureCount = 0;

var items = []; //used for storing items of the given floor
var itemCount = 0;




//weapons
//Weapon(name, type, gValue, power, numDice){
const sword01 = new Weapon("Turbo Lover", "greatsword", 600, 4,12);
const sword02 = new Weapon("Fate Sever", "dagger", 1000, 8,6);
const sword03 = new Weapon("Rainfall", "rapier", 20000, 1,6);
const fist00 = new Weapon("Unnarmed", "fist", 0, 1, 4);


var jobDefinitions = [];
//JobClass(className, hitDice, spellDice, strongth, agility, wisdom, startingSkills, startingSpells, startingWeapon, startingGold)
jobDefinitions[0] = new JobClass("Strong Hero", "hero", 12, 3, 10,4,1, [], [], sword01, 0);
jobDefinitions[1] = new JobClass("Fast Hero","hero", 10, 4, 5,8,2, [], [], sword02, 20);
jobDefinitions[2] = new JobClass("Wise Hero", "hero", 8, 8, 4,3,8, [],[], sword03, 100);
jobDefinitions[3] = new JobClass("Goblin", "goblin", 10, 1, 6,5,2, [], [] , fist00, {numDice:20, dieSize:8});
jobDefinitions[4] = new JobClass("Dragon", "dragon", 12, 4, 10,6,4, [], [], fist00, {numDice:20, dieSize:100});
jobDefinitions[5] = new JobClass("Golem", "golem", 20, 1, 8,2,1, [], [], fist00, {numDice:20, dieSize:6});

function getJobDef(id){
	switch(id.toUpperCase()){
		case "STRONG HERO":
			return jobDefinitions[0];
		case "FAST HERO":
			return jobDefinitions[1];
		case "WISE HERO":
			return jobDefinitions[2];
		case "GOBLIN":
			return jobDefinitions[3];
		case "DRAGON":
			return jobDefinitions[4];
		case "GOLEM":
			return jobDefinitions[5];
		default:
			return jobDefinitions[3];
	}
}

function getRandMonster(){
	var dRoll = Dice.roll(1,3);
	var index = null;
	switch(dRoll){
		case 1:
			index = "Goblin";
			break;
		case 2:
			index = "Dragon";
			break;
		case 3:
			index = "Golem";
			break;
		default:
			index = "Strong Hero";
			break;
	}
	return index;
}

//player initialization
var PLAYER_DEFAULTS = new Creature( creatureCount, "Strong Hero", new Position(WORLD_SIZE/2, WORLD_SIZE/2, 0), "Hiro", 1, sword01 , 10);
creatures[0] = PLAYER_DEFAULTS;
creatureCount++;
var playerIsAlive = true;
var player = 0;



imageLoader.loadQueuedImages(gameRestart);





function gameRestart(){

	/*TODO: 
	-clear the text window on restart
	*/
	world = [];
	creatures = [];
	creatureCount = 1;
	items = [];
	itemCount = 0;
	features = [];
	featuresCount = 0;

	turnCount = 0;

	creatures[player] = PLAYER_DEFAULTS;
	playerIsAlive = true;

	buildWorld();

	prepEventHandlers();
	drawFrame(creatures[player].position);
}



function gameOverFail(){
	writeLine("You have died...");
	//TODO: wait for user input (mouse click) and then go to score screen.
}


function gameOverWin(){
	writeLine("You have won!");
	//TODO: win screen (score screen) and wait for user input.
}




		//////////////////////
		// World Generation //
//////////////////////////////////////////////////////////////
//                             
//	buildWorld()
//	addFloor()	                       
//                              
//////////////////////////////////////////////////////////////
function buildWorld(){
	for(var ii = 0; ii < WORLD_DEPTH; ii++){
		addFloor("Floor " + (floorCount+1));
	}
}

function addFloor(name){
	floorCount++;
	world[floorCount -1] = new Floor(floorCount-1, name);
	world[floorCount -1].buildFloor();
}



function getGridIndex(x, y){
	return (x + y*WORLD_SIZE);
}


function getGridXY(index){
	var x = index % WORLD_SIZE;
	var y = (index - x) / WORLD_SIZE;

	return new Position(x,y);
}


function getTile(position){
	return world[position.floor].tileGrid[getGridIndex(position.x, position.y)];
}


		 //////////////////////      
		//	Constructors	//     
///////////////////////////////////////////////////
//
///////

//@constructor
function Position(x,y,floorId){
	this.x = x;
	this.y = y;
	this.floor = floorId;

	this.equals = function(other){
		if( this.x == other.x &&
			this.y == other.y &&
			this.floor == other.floor){
			return true;
		}
		return false;
	}
}

//@constructor
function Floor(id, name){

	this.id = id;
	this.name = name;

	this.tileGrid = [];
	this.tileCount = 0;

	this.findMe = function(floorName){
		if(floorName !=null){
			for(var ii = 0; ii< floorCount; ii++){
				if(world[ii].name == floorName){
					return ii;
				}
			}
		} else {
			for(var ii = 0; ii< floorCount; ii++){
				if(world[ii].name == this.name){
					return ii;
				}
			}
		}
		return -1;
	}

	this.buildFloor = function(genStyle){
		var s = "";
		if (genStyle != null) {
			s = genStyle;
		}
		//tiles and features:
		switch(s.toUpperCase()){
			case "SPARSE":
				this.buildSparse();
				break;
			case "MAZE":
				this.buildMaze();
				break;
			default:
				this.buildSparse();
		}
		//enemies
		this.spawnMonsters();
	}

	this.addTile = function(x,y, tile){
		this.tileGrid[getGridIndex(x,y)] = tile;
		this.tileCount++;
	}

	this.buildSparse = function(){
		var floorIndex = this.findMe();
		for(var ii = 0; ii < WORLD_SIZE; ii++){
			for(var kk = 0; kk < WORLD_SIZE; kk++){
				if((Dice.roll(1,4)) == 1){
					this.addTile(kk, ii, new Tile(this.tileCount, "WALL", new Position(kk,ii,floorIndex)));
				} else {
					this.addTile(kk, ii, new Tile(this.tileCount,"FLOOR", new Position(kk,ii,floorIndex)));
					if((Dice.roll(1,WORLD_SIZE)) == 1){
						this.addFeature( new Feature("Portal", "portal", new Position(kk,ii,floorIndex), new Position(kk,ii, Dice.roll(1,WORLD_DEPTH)-1)));
						this.createReciprocal(features[featureCount-1]);
					}
					if((Dice.roll(1,WORLD_SIZE)) == 1){
						this.addItem(new Item("gold", "treasure", new Position(kk,ii,floorIndex) ,Dice.roll(10,50)));
					}
				}
			}
		}
		//this.buildStairs();
		this.buildOuterWall();
	}

	this.buildStairs = function(floor){
		var numStairs = 10;

		for(var ii = 0; ii < numStairs; ii++){
			var xToTry = Dice.roll(1,WORLD_SIZE) - 1;
			var yToTry = Dice.roll(1,WORLD_SIZE) - 1;
			var floor = Dice.roll(1,WORLD_DEPTH) - 1;
			if(world[floor].tileGrid[getGridIndex(xToTry,yToTry)].isWalkable){
				this.addFeature( new Feature("Stairs", "door", new Position(xToTry,yToTry,floor), new Position(xToTry,yToTry, floor), true));
			}
		}
	}


	this.buildMaze = function(){
		//carving method: fill the whole grid with walls,
		this.fillGrid("WALL", grid);
		// then 'carve' out chunks for rooms and halls
	}


	this.fillGrid = function(tileType){
		for (var ii = 0; ii < WORLD_SIZE; ++ii) {
	        for (var kk = 0; kk < WORLD_SIZE; ++kk) {
			    this.addTile(kk, ii, new Tile(this.tileCount, tileType, new Position(kk,ii,this.findMe())));
	        }
		}
	}


	this.buildOuterWall = function(){
		for (var ii = 0; ii < WORLD_SIZE; ++ii) {
	        for (var kk = 0; kk < WORLD_SIZE; ++kk) {
				if (ii == 0 || ii == WORLD_SIZE - 1 || kk == 0 || kk == WORLD_SIZE - 1) {
		            this.addTile(kk, ii, new Tile(this.tileCount, "WALL", new Position(kk,ii,this.findMe())));
				}
	        }
		}
	}


	this.spawnMonsters = function(){
		for(var ii = 0; ii < NUM_ENEMIES; ii++){
			var success = false;
			var limit = 100 + NUM_ENEMIES * NUM_ENEMIES; //limiter to prevent endless loops in rare circumstances
			var count = 0;
			while(!success && count < limit){
				var xToTry = Dice.roll(1,WORLD_SIZE) - 1;
				var yToTry = Dice.roll(1,WORLD_SIZE) - 1;
				success = this.addMonster(xToTry, yToTry);
				count++;
			}
		}
	}

	this.addMonster = function(x, y){
		var success = false;
		var index = getGridIndex(x,y);
		var tile = this.tileGrid[index];
		//console.log("trying to add Monster at " +x + ", " + y);
		try{
			if(tile.hasCreature(index) == null && getTileDef(tile.type).isWalkable){
				//function Creature(id,type,icon,position,name,level)
				var namai = getRandMonster();
				var monster = new Creature(creatureCount, namai, new Position(x,y,this.id), namai, Dice.roll(1,4));
				this.addCreature(monster);
				success = true;
			}
		} catch(err){
			console.log("Error in addMonster: " + err);
		}
		return success;
	}



	this.addCreature = function(critter){
		if(this.tileGrid[critter.getIndex()].hasCreature() == null){  //creatures do not share space with eachother.
			creatures[creatureCount] = critter;
			creatureCount++;
		}
	}

	this.addFeature = function(mcguffin){
		if(this.tileGrid[mcguffin.getIndex()].hasFeature() == null){ //features do not share space with eachother, but can sometimes be part of a wall, pit, ect
			features[featureCount] = mcguffin;
			featureCount++;
		}
	}

	this.createReciprocal = function(portal){
		this.addFeature( new Feature(portal.name, portal.icon, portal.destination, portal.position));
	}

	this.addItem = function(item){
		if(this.tileGrid[item.getIndex()].hasFeature() == null){ //items cannot share space with Features, walls, pits, ect...
			items[itemCount] = item;
			itemCount++;
		}
	}

}


//@constructor
function TileDefinition(name, icon, isWalkable) {
	this.name = name;
	this.icon = icon;
	this.isWalkable = isWalkable;
}


//@constructor
function Tile(id, tileType, position){
	this.id = id; //unique id
	this.type = tileType; //identifier for indexing into array of tile definitions.
	this.position = position;

	this.hasCreature = function(index){
		try{
			if(index != null){
				for(var ii = 0; ii < creatureCount; ii++){
					if(creatures[ii].position.floor == this.position.floor){
						if(creatures[ii].position.x == getGridXY(index).x  &&
							creatures[ii].position.y == getGridXY(index).y){
							return ii;
						}
					}
				}
			} else {
				for(var ii = 0; ii < creatureCount; ii++){
					if(creatures[ii].position.floor == this.position.floor){
						if(creatures[ii].position.x == getGridXY(this.id).x  &&
							creatures[ii].position.y == getGridXY(this.id).y){
							return ii;
						}
					}
				}
			}
		} catch(err){
			console.log("Error in Tile.hasCreature(): " + err);
		}
		return null;
	}


	this.hasFeature = function(index){
		try{
			if(index != null){
				for(var ii = 0; ii < featureCount; ii++){
					if(features[ii].position.floor == this.position.floor){
						if(features[ii].position.x == getGridXY(index).x  &&
							features[ii].position.y == getGridXY(index).y){
							return ii;
						}
					}
				}
			} else {
				for(var ii = 0; ii < featureCount; ii++){
					if(features[ii].position.floor == this.position.floor){
						if(features[ii].position.x == getGridXY(this.id).x  &&
							features[ii].position.y == getGridXY(this.id).y){
							return ii;
						}
					}
				}
			}
		} catch(err){
			console.log("Error in Tile.hasFeature(): " + err);
		}
		return null;
	}


	this.hasItem = function(index){
		if(index != null){
			for(var ii = 0; ii < itemCount; ii++){
				if(items[ii].position.floor == this.position.floor){
					if(items[ii].position.x == getGridXY(index).x  &&
						items[ii].position.y == getGridXY(index).y){
						return ii;
					}
				}
			}
		} else {
			for(var ii = 0; ii < itemCount; ii++){
				if(items[ii].position.floor == this.position.floor){
					if(items[ii].position.x == getGridXY(this.id).x  &&
						items[ii].position.y == getGridXY(this.id).y){
						return ii;
					}
				}
			}
		}
		return null;
	}
}




//@constructor
function Feature(name, icon, position, destination, properties){
	this.name = name;
	this.icon = icon;
	this.position = position; //Position obj
	this.destination = destination; //if this is a stairs or portal, where does it go? Position obj.
	this.properties = properties; //{} or [] of other properties.

	this.getIndex = function(){
		return getGridIndex(position.x, position.y);
	}

	this.findMe = function(){ //returns the index into features[] that matches this feature's position.
		for(var ii = 0; ii< featureCount; ii++){
			if(features[ii].position.equals(this.position)){
				return ii;
			}
		}
		return null;
	}


	this.hasDestination = function(){
		if(this.destination != null){
			return true;
		} 
		return false;
	}

}


//@constructor
function Item(name, icon, position, quantity, properties){
	this.name = name;
	this.icon = icon;
	this.position = position;
	this.quantity = quantity;
	this.properties = properties;

	this.getIndex = function(){
		return getGridIndex(position.x, position.y);
	}
}


//constructor
function Creature(id,job,position,name,level){
	//system data
	this.id = id;
	this.job = job; //JobClass obj; contains stat rates for leveling.
	this.icon = getJobDef(this.job).icon;
	this.position = position; //Position obj (x,y)
	
	//character data
	this.name = name;
	this.level = level;
	this.exp = 0;
	
	//stats
	this.healthMax = level * getJobDef(this.job).hitDice;
	this.currentHealth = this.healthMax;
	this.manaMax = level * getJobDef(this.job).spellDice;
	this.currentMana = this.manaMax;

	this.strongth = level * getJobDef(this.job).strongth; 
	this.agility = level * getJobDef(this.job).agility;
	this.wisdom = level * getJobDef(this.job).wisdom;

	this.skills = getJobDef(this.job).startingSkills; //array[] of skills values in doubles.
	this.spells = getJobDef(this.job).startingSpells;

	//posessions
	this.weapon = getJobDef(this.job).startingWeapon;
	if(getJobDef(this.job).startingGold.numDice != null){
		this.gold = Dice.roll(getJobDef(this.job).startingGold.numDice, getJobDef(this.job).startingGold.dieSize);
	} else {
		this.gold = getJobDef(this.job).startingGold;
	}
	this.inventory = [];

	this.getIndex = function(){
		return getGridIndex(position.x, position.y);
	}

	this.findMe = function(){ //returns the index into creatures[] that matches this creature's position.
		for(var ii = 0; ii< creatureCount; ii++){
			if(creatures[ii].position.equals(this.position)){
				return ii;
			}
		}
		return null;
	}

	this.attack = function(target){
		if(target != null){
			var dmg = this.getDmg();
			// dmg = Math.floor(dmg);
			writeLine(this.name + " attacks " + target.name + " for " + dmg + ".");
			target.currentHealth -= (dmg);

			if(target.currentHealth < 0){
				writeLine(this.name + " slays " + target.name + ".");
				this.getExp(target.level * EXP_RATE);
				target.dies();
			} else{
				target.counterAttack(this);
			}
		}
	}

	this.counterAttack = function(attacker){
		if(attacker != null){
			var dmg = this.getDmg();
			writeLine(this.name + " attacks " + attacker.name + " for " + dmg + ".");
			attacker.currentHealth -= (dmg);
			if(attacker.currentHealth < 0){
				writeLine(this.name + " slays " + attacker.name + ".");
				this.getExp(attacker.level * EXP_RATE);
				attacker.dies();
			}
		}
	}


	this.getDmg = function(){
		return Math.floor(DAMAGE_RATE * this.strongth + Dice.roll(this.weapon.numDice, this.weapon.damageDice));
	}

	this.dies = function(){
		console.log("In Creature.dies(): " + this.findMe() + ": " + this.name);
		if(this.findMe() == player){
			playerIsAlive = false;
			creatures.splice(this.findMe(), 1);
			creatureCount--;
		} else {
			if(this.gold > 0){
				items[itemCount] = new Item("gold","treasure", this.position, this.gold);
				itemCount++;
			}
			creatures.splice(this.findMe(), 1);
			creatureCount--;
		}
	}

	this.getExp = function(val){
		this.exp += val;
		if(this.findMe() == player){
			writeLine("You got " + val + " experience.");
		}
		if(this.exp > (this.level+1) * (this.level+1)){
			this.levelUp();
		}
	}

	this.levelUp = function(){
		this.level++;
		this.exp -= level * level;
		this.healthMax += getJobDef(this.job).hitDice;
		this.currentHealth = this.healthMax;
		this.manaMax += getJobDef(this.job).spellDice;
		this.currentMana = this.manaMax;
		this.strongth += getJobDef(this.job).strongth;
		this.agility += getJobDef(this.job).agility;
		this.wisdom += getJobDef(this.job).wisdom;

		writeLine("You have reached Level " + this.level + "!");
	}


	this.tryMove = function(moveX, moveY, floor){

		var pos = new Position (this.position.x + moveX, this.position.y + moveY, this.position.floor);
		var moveIndex = getGridIndex(pos.x,pos.y);
		var peek = peekAt(pos.x, pos.y, pos.floor);
		//console.log("In tryMove(): peek: " + peek );
		switch(peek){
			case "WALKABLE":
				this.position.x += moveX;
				this.position.y += moveY;
				if(floor != null){
					this.position.floor = floor;
				}
				break;
			case "CREATURE":
				this.attack(creatures[world[pos.floor].tileGrid[moveIndex].hasCreature()]);
				break;
			case "WALL":
				writeLine("Ooof!");
			default:
				break;
		}
	}

	this.teleport = function(destination){

		if(getTileDef(getTile(destination).type).isWalkable){
			this.position = destination;
			writeLine("The portal takes you to " + world[this.position.floor].name + ".");
		} else {
			writeLine("Cannot teleport to destination.");
		}
	}

	this.interactWith = function(feature){
		//is it a portal? (stairs, trap doors, gateways)

		if(feature.destination != null){
			this.teleport(feature.destination);
		}
		//is it a fountain?
		//is it a shop?
		//is it a shrine?
	}

	this.pickUp = function(itemIndex){
		if(items[itemIndex].name == "gold"){
			this.gold += items[itemIndex].quantity;
			items.splice(itemIndex,1);
			itemCount--;
		} else {
			this.iventory[this.inventory.length] += items[itemIndex];
			items.splice(itemIndex,1);
			itemCount--;
		}
	}

}



//@constructor
function Weapon(name, type, gValue, numDice, damageDice){
	this.name = name;
	this.type = type;
	this.gValue = gValue;
	this.damageDice = damageDice;
	this.numDice = numDice;

}


//@constructor
function JobClass(className, icon, hitDice, spellDice, strongth, agility, wisdom, startingSkills, startingSpells, startingWeapon, startingGold){
	this.className = className;
	this.icon = icon;
	this.hitDice = hitDice;
	this.spellDice = spellDice;

	this.strongth = strongth; 
	this.agility = agility;
	this.wisdom = wisdom;

	this.startingSkills = startingSkills; //array[] of skills values in doubles.
	this.startingSpells = startingSpells;

	//posessions
	this.startingWeapon = startingWeapon;
	this.startingGold = startingGold;
	//this.equipment = startingEquips;
}






		/////////////////////
		// Event Listeners //
//////////////////////////////////////////////////////////////
//                             
//	prepEventHandlers();
//  playerKeyup(ee);
//	playerMove(direction);
//  playerClick(ee);
//	peekAt();	                       
//                              
//////////////////////////////////////////////////////////////
function prepEventHandlers(){
	document.addEventListener("keydown", playerKey, false);
	document.addEventListener("click", playerClick, false);
	console.log("in prepEventHandlers()");
}





function playerKey(ee){

	switch(ee.keyCode){
		case 37: //left arrow
		case 100: //numpad 4
			playerMove("LEFT");
			break;
		case 38: //up arrow
		case 104: //numpad 8
			playerMove("UP");
			break;
		case 39: //right arrow
		case 102: //numpad 6
			playerMove("RIGHT");
			break;
		case 40: // down arrow
		case 98: //numpad 2
			playerMove("DOWN");
			break;
		case 97: //numpad 1
			playerMove("SOUTHWEST");
			break;
		case 103: //numpad 7
			playerMove("NORTHWEST");
			break;
		case 105: //numpad 9
			playerMove("NORTHEAST");
			break;
		case 99: //numpad 3
			playerMove("SOUTHEAST");
			break;
		case 101: //numpad 5
			playerMove("WAIT");
			break;
		case 96: //numpad 0
		case 13: //enter key
			playerMove("USE")
			break;
		default:
			return;
	}

}




//TODO: documentation for playerMove()
// A lot of the game logic goes through this function, it enables 8 directional movement for the player character, and combat.
function playerMove(direction){
	var currentIndex = getGridIndex(creatures[player].position.x,creatures[player].position.y);
	var currentFloor = creatures[player].position.floor;

	if(playerIsAlive){
		switch(direction){
			case "LEFT":
				creatures[player].tryMove(-1,0);
				break;

			case "UP":
				creatures[player].tryMove(0,-1);
				break;

			case "RIGHT":
				creatures[player].tryMove(1,0);
				break;

			case "DOWN":
				creatures[player].tryMove(0,1);
				break;

			case "SOUTHWEST":
				creatures[player].tryMove(-1,1);
				break;

			case "NORTHWEST":
				creatures[player].tryMove(-1,-1);
				break;

			case "NORTHEAST":
				creatures[player].tryMove(1,-1);
				break;

			case "SOUTHEAST":
				creatures[player].tryMove(1,1);
				break;

			case "WAIT":
				//resting and repeated item pick-up
				creatures[player].currentHealth += creatures[player].level;
				creatures[player].currentMana += creatures[player].level;
				if(creatures[player].currentHealth > creatures[player].healthMax){
					creatures[player].currentHealth = creatures[player].healthMax;
				}
				if(creatures[player].currentMana > creatures[player].manaMax){
					creatures[player].currentMana = creatures[player].manaMax;
				}
				writeLine("You rest and restore " + creatures[player].level + " health and mana. HP: " + creatures[player].currentHealth + "/" + creatures[player].healthMax + " MP: " + creatures[player].currentMana + "/" + creatures[player].manaMax);
				break;

			case "USE":
				//interact with features or respond to user prompts in the text area.
				if(world[currentFloor].tileGrid[currentIndex].hasFeature() != null){
					var featureIndex = world[currentFloor].tileGrid[currentIndex].hasFeature();
					var feature = features[featureIndex]
					creatures[player].interactWith(feature);
				} else {
					writeLine("Nothing to interact with.");
				}
				break;

			default:
				return;
		}
		currentIndex = getGridIndex(creatures[player].position.x,creatures[player].position.y);

		//check for items, pick up the first one found in the list.
		if(world[currentFloor].tileGrid[currentIndex].hasItem() != null){
			var itemIndex = world[currentFloor].tileGrid[currentIndex].hasItem(currentIndex);
			var anItem = items[itemIndex];
			var line = "You pick up " + anItem.quantity + " " + anItem.name + ".";
			creatures[player].pickUp(itemIndex);
			if(anItem.name == "gold"){
				line += " You now have " + creatures[player].gold + " gold.";
			}
			writeLine(line);
		}

		console.log("[Turn " + turnCount + "] moved to " + creatures[player].position.x + ", " + creatures[player].position.y + "; " + world[creatures[player].position.floor].name);
		turnCount++;
	} else { //player has died:
		gameOverFail();
	}

	drawFrame(creatures[player].position);
}



function peekAt(x, y, floorId){
	var floor = world[floorId];
	if(!getTileDef(floor.tileGrid[getGridIndex(x, y)].type).isWalkable){
		return "WALL";
	}
	if(floor.tileGrid[getGridIndex(x, y)].hasCreature() != null){
		return "CREATURE";
	}

	return "WALKABLE";
}

function playerClick(ee){


}



///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////






		///////////////
		// Rendering //
//////////////////////////////////////////////////////////////
//                             
//	drawFram(center)
//	clearDisplay(display, ctx)
//	drawTile(ctx, posX, posY, tile)  
//	writeLine(line)                     
//                              
//////////////////////////////////////////////////////////////
function drawFrame(center){
	var display = document.getElementById("gameDisplay");
	var ctx = display.getContext("2d");
	if(display.getContext) {

		clearDisplay(display, ctx);

		var widthAdjust = (DISPLAY_WIDTH - 1)/2;
		var heightAdjust = (DISPLAY_HEIGHT - 1)/2;

		var upperLeft = new Position(Math.max(center.x - widthAdjust, 0), Math.max(center.y - heightAdjust,0));
		if(upperLeft.x > (WORLD_SIZE - DISPLAY_WIDTH)){
			upperLeft.x = WORLD_SIZE - DISPLAY_WIDTH;
		}
		if(upperLeft.y > WORLD_SIZE - DISPLAY_HEIGHT){
			upperLeft.y = WORLD_SIZE - DISPLAY_HEIGHT;
		}
		// console.log("upperLeft = " + upperLeft.x + ", " + upperLeft.y);
		//var lowerRightIndex = getGridIndex(Math.max(center.x + 10, 0), Math.max(center.y + 6,0));

		//DRAW THE TILES
		for(var ii = 0; ii < DISPLAY_HEIGHT; ii++){
			for(var kk = 0; kk < DISPLAY_WIDTH; kk++){
				var index = getGridIndex(upperLeft.x, upperLeft.y) + getGridIndex(kk,ii);
				if(index >= 0 && index < (WORLD_SIZE*WORLD_SIZE)){
					drawTile(ctx, kk, ii, world[center.floor].tileGrid[index]);
				}
			}
		}



	}
}



//@citation: user: Prestaul at http://stackoverflow.com/questions/2142535/how-to-clear-the-canvas-for-redrawing
function clearDisplay(display, ctx){
// Store the current transformation matrix
ctx.save();

// Use the identity matrix while clearing the canvas
ctx.setTransform(1, 0, 0, 1, 0, 0);
ctx.clearRect(0, 0, display.width, display.height);

// Restore the transform
ctx.restore();
}



//posx and posy are x,y coordinates relative of hte upperleft corner of the view.
function drawTile(ctx, posX, posY, tile){
	
	var imageName = getTileDef(tile.type).icon;
	//order of operations:
	//draw base: 
	ctx.drawImage(imageLoader.images[imageName], posX*TILE_SIZE, posY*TILE_SIZE);
	//draw features: (like doors, stairs)
	if(tile.hasFeature() != null){
		//console.log("In drawTile(): feature.");
		imageName = features[tile.hasFeature()].icon;
		ctx.drawImage(imageLoader.images[imageName], posX*TILE_SIZE, posY*TILE_SIZE);
	}
	//draw items:
	if(tile.hasItem() != null){
		imageName = items[tile.hasItem()].icon;
		ctx.drawImage(imageLoader.images[imageName], posX*TILE_SIZE, posY*TILE_SIZE);
	}
	//draw creatures:
	if(tile.hasCreature() != null){
		imageName = creatures[tile.hasCreature()].icon;
		ctx.drawImage(imageLoader.images[imageName], posX*TILE_SIZE, posY*TILE_SIZE);
	}
}


//////  Text display 

function writeLine(line){
	var outputTextArea = document.getElementById("outputText");
	document.getElementById("outputText").value += line + "\n";
	
	outputTextArea.scrollTop = outputTextArea.scrollHeight - outputTextArea.clientHeight;
}

function printList(array){
	var line;

	for(var ii = 0; ii < array.length; ii++){
		line += array[ii] + "\n";
	}

	writeLine(line);
}



//@depricated ;keeping this around for reference.
function handleInput(){
	var inputTextArea = document.getElementById("inputText");
	var outputTextArea = document.getElementById("outputText");
	
	var text = inputTextArea.value;
	

	document.getElementById("inputText").value = "";
	
	outputTextArea.scrollTop = outputTextArea.scrollHeight - outputTextArea.clientHeight;
	
	return false;
}



</script>
</head>
